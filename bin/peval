#!/usr/bin/env python

import sys
import csv
from itertools import count, izip
from optparse import OptionParser
from dbp.util import dbprint
from dbp.paxos.agent import NodeProtocol
from dbp import config, util
from twisted.internet import reactor
from collections import namedtuple
from timeit import default_timer as clock
from twisted.python import log


Timing = namedtuple('Timing', ('start', 'end'))


class LimitedTransport(object):

    limit = 12500000  # 1 megabit == 125,000 bytes
    #div = 10
    div = 1

    def __init__(self, transport, clock=None, debug=False):
        if clock is None:
            self.clock = reactor
        self.transport = transport
        self.dropped_count = 0
        self.debug = debug
        self.reset_quota()

    def reset_quota(self):
        self.quota = self.limit//self.div
        self.clock.callLater(1.0/self.div, self.reset_quota)

    def write(self, data, host=None):
        """Wrapper around TStringTransport.write"""
        # drop packet if we don't have room for it
        if len(data) > self.quota:
            self.dropped_count += 1
            # if self.debug:
            #     print >>sys.stderr, "dropped %d'th packet (%s)" % (self.dropped_count, data)
            # return
        self.quota -= len(data)
        self.transport.write(data, host)


class NodeManager(object):
    start_port = 10000

    @staticmethod
    def make_lmt_node(port, args):
        n = NodeProtocol(*args)
        t = reactor.listenUDP(port, n)
        n.transport = LimitedTransport(t)
        return n

    def __init__(self, node_num):
        self.master = self.make_lmt_node(self.start_port, ())
        self.nodes = [self.master]
        for x in xrange(1, node_num):
            n = self.make_lmt_node(self.start_port + x,
                                   [("localhost", self.start_port)])
            self.nodes.append(n)

    def finish(self):
        for n in self.nodes:
            n.dropped_count = n.transport.dropped_count


class ThroughputMetric(NodeManager):

    def start_run(self, amount, values):
        """Start run: measure throughput of master node, queuing TXs immediately"""
        self.start = clock()
        self.num = amount

        node = self.master
        for n, v in izip(xrange(amount), values):
            d = node.run(v)
            d.addCallback(self.end_run)
            d.addErrback(log.err)

    def end_run(self, _):
        self.num -= 1
        if not self.num:
            self.finish()

    def finish(self):
        super(ThroughputMetric, self).finish()
        self.end = clock()
        reactor.stop()

    def output(self, file):
        #print self.transport.dropped_count
        print "%s seconds" % (self.end-self.start)

class LatencyMetric(NodeManager):

    def start_run(self, amount, values):
        """Start run: measure latency of master node, queuing TXs immediately"""
        self.num = amount
        self.timings = []

        node = self.master
        for n, v in izip(xrange(amount), values):
            c = clock()
            d = node.run(v)
            d.addCallback(lambda r:self.end_run(c))
            d.addErrback(log.err)

    def end_run(self, start):
        self.num -= 1
        t = Timing(start, clock())
        self.timings.append(t)
        if not self.num:
            self.finish()

    def finish(self):
        super(LatencyMetric, self).finish()
        reactor.stop()

    def output(self, file):
        with open(file, 'wb') as csvfile:
            c = csv.writer(csvfile)
            for n, t in enumerate(self.timings):
                c.writerow([n, t.start, t.end])




def main():
    usage = "usage: %prog [options]"
    parser = OptionParser(usage=usage)
    parser.add_option("-m", "--metric", action="store", default="lat",
                      help="type of metric to measure [valid options are lat,thru]")
    parser.add_option("-o", "--ops", action="store", type="int",
                      help="number of operations to run per node")
    parser.add_option("-n", "--nodes", action="store", type="int",
                      help="number of nodes to run")
    parser.add_option("-f", "--file", action="store", default="peval.csv",
                      help="csv file to use")
    parser.add_option("-D", "--debug", action="store", type="int", default=config.DEBUG,
                      help="debug level to run at")

    (options, args) = parser.parse_args()
    if options.nodes is None:
        parser.error("Need to specify number of nodes")
    if options.ops is None:
        parser.error("Need to specify number of ops")
    if options.file is None:
        parser.error("Need to specify csv file to use")
    i = (x+1 for x in count())

    if options.metric == "lat":
        kls = LatencyMetric
    elif options.metric == "thru":
        kls = ThroughputMetric

    util.DEBUG = options.debug

    m = kls(options.nodes)

    reactor.callLater(7, m.start_run, options.ops, i)
    reactor.run()

    m.output(options.file)
    print m.master.dropped_count


if __name__ == "__main__":
    main()
