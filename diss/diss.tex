% Based on template by MR

\documentclass[12pt,twoside,notitlepage]{report}

\usepackage{a4}
\usepackage{verbatim}

\input{epsf}                            % to allow postscript inclusions
% On thor and CUS read top of file:
%     /opt/TeX/lib/texmf/tex/dvips/epsf.sty
% On CL machines read:
%     /usr/lib/tex/macros/dvips/epsf.tex



\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\addtolength{\oddsidemargin}{6mm}       % adjust margins
\addtolength{\evensidemargin}{-8mm}

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable

\begin{document}

\bibliographystyle{plain}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

\hfill{\LARGE \bf Charlie Shepherd}

\vspace*{60mm}
\begin{center}
\Huge
{\bf PDB: A Distributed Database Based on Paxos} \\
\vspace*{5mm}
Computer Science Tripos \\
\vspace*{5mm}
Churchill College \\
\vspace*{5mm}
\today  % today's date
\end{center}

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\setcounter{page}{1}
\pagenumbering{roman}
\pagestyle{plain}

\chapter*{Proforma}

{\large
\begin{tabular}{ll}
Name:               & \bf Charlie Shepherd                        \\
College:            & \bf Churchill College                     \\
Project Title:      & \bf PDB: A Distributed Database Based on Paxos \\
Examination:        & \bf Computer Science Tripos, July 2013        \\
Word Count:         & \bf wordcount \\
Project Originator: & Charlie Shepherd                    \\
Supervisor:         & Stephen Cross                    \\
\end{tabular}
}


\section*{Original Aims of the Project}

\subsection*{Project aims}

I aim to implement a distributed database. This will be based on the Paxos protocol.

\subsubsection*{Paxos}

The first half of the project is to implement the Paxos protocol. This will be done in a module,
providing an interface which the database can then use to 

The project must correctly implement the Paxos protocol.
The library must be capable of forming a running network,
in particular dynamic leader election,
as well as achieving consensus on a key/value store across the network.

\subsubsection*{Database}

The database must implement a subset of SQL, specifically:
\begin{enumerate}
\item A single table with a static name
\item SELECT/INSERT
\item WHERE
\item GROUP BY
\item ORDER BY
\item Aggregation
\end{enumerate}

The database must have all ACID properties, that is:


\section*{Work Completed}

All that has been completed appears in this dissertation.

\section*{Special Difficulties}

None.

\newpage
\section*{Declaration}

I, Charlie Shepherd of Churchill College, being a candidate for Part II of the Computer Science
Tripos, hereby declare that this dissertation and the work described in it are my own work,
unaided except as may be specified below, and that the dissertation does not contain material that
has already been used to any substantial extent for a comparable purpose.

\bigskip
\leftline{Signed: }

\medskip
\leftline{Date: \today}

\cleardoublepage

\tableofcontents

\listoffigures

\newpage
\section*{Acknowledgements}

Acknowledge various people

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the chapters

\cleardoublepage        % just to make sure before the page numbering
                        % is changed

\setcounter{page}{1}
\pagenumbering{arabic}
\pagestyle{headings}

\chapter{Introduction}

\section{Overview}

\section{Motivation}

I set out to build a distributed database based on Paxos. Paxos was first described in Leslie
Lamport's paper \emph{The Part Time Parliament} \cite{lamport98}.

how it integrates with ecosystem (aka what's already out there).


talk about distributed, p2p advantages


\section{Distributed Consensus Problem}

Consensus is an integral problem in distributed systems. The consensus problem is that of getting
all nodes in a distributed system to agree on a value. Formally, an algorithm that satisfies the
consensus problem satisfies three properties:

A process must decide on a value only once, and cannot change the value once it has been decided.

\begin{enumerate}
\item Agreement - all nodes must decide the same value
\item Validity - the value that is decided upon must have been proposed by some node in the
	network
\item Termination - all nodes eventually decide on a value
\end{enumerate}

\subsection*{2 Phase Commit}

2 Phase Commit (2PC) is one of the simplest consensus protocol, and one of the most brittle. It has two
phases:

\begin{enumerate}
\item Send a message to each node asking them to accept the value proposed.
\item If all nodes respond with a YES message, send a CONFIRM message. Else, send an ABORT message
	to all nodes.
\end{enumerate}

This has a number of failures that it is vulnerable too. If a single node crashes, the entire
protocol will hang, as the co-ordinator will wait for the node to come back online. 

\subsection*{3 Phase Commit}

3 Phase Commit (3PC) is a modification of 2PC that avoids the most common failure mode - that of a
cohort member.

\subsection*{Paxos}

Paxos is a generalisation of 2PC and 3PC that handles more failure modes. I will go into a detailed
explanation in the Preparation chapter, here I will just summarise it. 

\section{Databases}

\subsection*{ACID}

Commonly all databases provide ACID properties. ACID stands for:

\begin{itemize}
\item Atomic - an operation is either performed or is not performed.
\item Consistent - the database remains in a consistent state at all times.
\item Isolated - one operation cannot see the intermediate state due to another operation occurring
	at the same time.
\item Durable - once an operation is "commited" it is permanently stored - the effects of it will
	not be lost.
\end{itemize}

\subsection*{Centralisation vs Distributed}

Databases are generally found in one of two topologies - centralised or distributed. These
different topologies are used in different situations and to different ends.

A centralised database is a single node in a single location.
In general, centralised databases are simpler in design and on the whole faster than distributed
databases.
Many general properties of centralised vs. distributed systems apply to centralised databases -
they are easier to perform organise, to edit, to query and to backup. May slow down under load. It
is easier to maintain the integrity of data on a centralised database, as there is only one
"current" version of the data under consideration.

In contrast, distributed databases are more resilient and scalable than centralised databases.
There is no longer a single point of failure, and they can be extended by adding nodes, although
this will have a point of diminishing returns. Distributed databases are often more complex in
design, as they have to ensure consistency between nodes (although there is a recent trend to
relax this constraint in certain "NoSQL" databases. Here I will only consider traditional RDBMS
systems). In particular, distributed databases can be slow accessing non local data.

\subsection*{Existing Paxos databases}

Paxos has recently become a very popular algorithm for ensuring distributed consensus. One good
example is Google using Paxos for a distributed lock service called "Chubby". This underpins their
BigTable distributed database which is used across Google.

(XXX: Need some more examples.)

\cleardoublepage

\chapter{Preparation}

\section{Paxos}

\subsection{Introduction}

Paxos is a distributed consensus protocol. It was developed by Leslie Lamport at Microsoft
research when he was trying to disprove its existence. Paxos is failure tolerant for up to F
simulatneous failures in a network of 2F+1 nodes.

Paxos is actually a family of protocols, based around the same main algorithm. the Paxos algorithm
is an algorithm for agreeing on a single value across a network of processors. Paxos provides
three guarantees: safety, liveness and non-triviality.

\begin{enumerate}
	\item Safety: All nodes eventually agree on the value chosen
	\item Liveness: If a value is proposed, it will eventually be chosen (?? XXX)
	\item Non-triviality: Some value is learnt (this constraint is because the previous two guarantees can
be satisfied without any values being learnt).
\end{enumerate}

Paxos can tolerate certain kinds of failures. These are: messages being delivered late or not at
all, etc XXX.

However Paxos cannot tolerate "rogue" processes, that is, processes deliberately sending malicious
or incorrect messages. There is a variant of Paxos called Byzantine Paxos which can tolerate this,
albeit at a failure tolerance of F for XXX nodes.


\subsection{Definitions}

\subsubsection*{Proposal Numbering}

One of the assumptions that Paxos makes is that every proposal has a unique proposal number. This
is necessary so that proposals have a \emph{total order}, ie we can compare any two proposals to
find the maximum ordered proposal. The conventional way to achieve this is to define a proposal
number as a 2-tuple of (sequence number, node address). These can be compared lexicographically,
and as node addresses are unique, every proposal number will be unique. In practice I plan to use
UUIDs as node identifiers, in order to be confident on uniqueness.

\subsubsection*{Quorums}

Paxos relies on quorums to ensure that 

\subsubsection*{Messages}

Paxos utilises several message types

\subsection{How it works}

\subsection{MultiPaxos}

MultiPaxos is multiple rounds of Paxos occuring at the same time. The way this is outlined in
\emph{Paxos Made Simple} is by a form of leader election. I will outline this here but, for
simplicity, in my project I will simply use multiple Paxos rounds to form the basis of a
distributed operation log. This will be explained in more detail in the Implementation chapter.

\section{ACID}

\subsubsection*{Atomic}

Atomicity means that either an operation completes, or it does not, ie, that the database is not
left in a "halfway" state. This means that we do not need to worry about cleaning up after an
operation, if it does not succeed we can simply retry it, without needing to worry about the state
it has left the database in. Atomicity also applies to transactions in the same way - if we have
a transaction as an operation composed of smaller single operations (for example, INCR B, READ A
$\rightarrow$ X, WRITE X+10 $\rightarrow$ A), we don't want some of the operations to complete
and some not to. In this example, we may have the constraint $A = 10 * B$. If B was incremented but then
the transaction failed before A was updated, we would leave the database in an inconsistent state.

\subsubsection*{Consistent}

Consistency is very closely related to atomicity, as consistency refers to a property of the
database, and atomicity refers to a property of operations performed on the database. In the
example used for atomicity, we had a constraint on the database (that A=B*10). We want operations
(or transactions) to transform the database from one consistent state to another. This becomes
more pertinent in distributed databases, as we may receive operations in one order at one node,
and in a different order at another node. If we apply the operations in the order that we receive
them, the two nodes are likely to be in inconsistent states. XXX: define consistency in a
distributed system.

\subsubsection*{Isolated}

\subsubsection*{Durable}

\section{Software Engineering}

\subsection{Module Dependencies}

I chose Twisted in order to make implementing the protocol easier. Twisted provides a lot of
support for implementing protocols and helper classes etc. Also as I am using a state machine
approach to implementing DBP and Paxos, twisted's asynchronous system works very well with this
approach.

\subsection{Programming Language}

There were several options for which programming language to use for this project. C - too
verbose, erlang - too weird, python - just right?

\section{Requirements Analysis}

Requirements for my system:
Transactions
ACID properties

\subsection{Software Development Process}

Considered using the waterfall model, but didn't fit my requirements (fast prototyping to
understand Paxos). Decided on spiral because of xyz.

\subsection{Version Control and Backup Strategy}

For version control I decided to use Git, as it is a system I am familiar with, and serves my need
both as a VCS and as a remote backup. In my experience it is more usable than other DVCSs such as
Bazaar, Darcs or Mercurial, and much faster than centralised VCSs such as CVS or SVN. Using Git I
backed up my project both to bitbucket, an online repository service which provides free private
repository hosting, and to my own server.

For backups I use the PWF to develop my project on. As it is stored in Git I can back it up simply
by pushing the repo to other hosts. I currently have it backed up to two other hosts.

\subsection{Testing}

Testing is really important
network
lots of effects
lots of subsystems

\subsubsection{Unit Testing}

unit testing really key
regression testing
testing different subsystems

\subsubsection{Integration Testing}

test program etc
see simple change propagate across complex system



\cleardoublepage
\chapter{Implementation}

SQL parser
- what it supports

-start up costs
  - ping time etc
  - inefficiencies
  - cf. "supernodes" vs DHTs to organise nodes

Talk about laptop breaking


\cleardoublepage
\chapter{Evaluation}

This is where the second most amount of marks are gained.

\section{Testing}

\begin{enumerate}
	\item unit test inertia
	\item test programs, see complex effects of single change.
	\item durable - network - stable storage
\end{enumerate}



\cleardoublepage
\chapter{Conclusion}

Conclude here.




\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the bibliography

\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{refs}
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the appendices
\appendix

\chapter{Project Proposal}

\input{propbody}

\end{document}
